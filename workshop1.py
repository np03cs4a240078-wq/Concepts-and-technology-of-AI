# -*- coding: utf-8 -*-
"""workshop1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yANHU0VWpjnCJri5DhRguTZQGnaVkqd9
"""

import numpy as np

# 1. Initialize an empty array with size 2x2
empty_array = np.empty((2, 2))
print("Empty Array:\n", empty_array)

# 2. Initialize an all-one array with size 4x2
ones_array = np.ones((4, 2))
print("\nAll-One Array (4x2):\n", ones_array)

# 3. Return a new array of given shape and type, filled with fill value
# Example: shape = (3,3), fill value = 7, dtype = int
filled_array = np.full((3, 3), 7, dtype=int)
print("\nFilled Array (3x3) with 7:\n", filled_array)

# 4. Return a new array of zeros with same shape and type as a given array
array = np.array([[1, 2, 3], [4, 5, 6]])
zeros_like_array = np.zeros_like(array)
print("\nZeros Like Array:\n", zeros_like_array)

# 5. Return a new array of ones with same shape and type as a given array
ones_like_array = np.ones_like(array)
print("\nOnes Like  Array:\n", ones_like_array)

# 6. Convert a list to a numpy array
new_list = [1, 2, 3, 4]
array_from_list = np.array(new_list)
print("\nArray from List:\n", array_from_list)

import numpy as np

# Q1. Array with values from 10 to 49
a1 = np.arange(10, 50)
print("Array from 10 to 49:\n", a1)


#  Q2. 3x3 matrix with values 0 to 8
a2 = np.arange(9).reshape(3,3)
print("\n 3x3 Matrix 0 to 8:\n", a2)


# Q3. 3x3 identity matrix
identity_matrix = np.eye(3)
print("\n3. 3x3 Identity Matrix:\n", identity_matrix)


#   Q4. Create a random array of size 30 and find the mean
d = np.random.random(30)
print("\n4. Random array OF 30 and its  mean:\n", d.mean())





# Q5. 10x10 random array  and its min & max
e = np.random.random((10, 10))
print("\n5. Min value of array:", e.min())
print("   Max value of array:", e.max())


# Q6. Zero array of size 10, replace 5th element with 1
f = np.zeros(10)
f[4] = 1    # index 4 is the 5th element
print("\n6. Zero array with 5th element = 1:\n", f)


# Q7. Reverse array
arr = np.array([1, 2, 0, 0, 4, 0])
ga = arr[::-1]
print("\n7. Reversed array:\n", ga)



# Q8. 2D array with 1 on border and 0 inside (5x5 example)
border_arr = np.ones((5,5))
border_arr[1:-1, 1:-1] = 0
print("\n8. 2D Array with 1 on border and 0 inside:\n", border_arr)


# Q9. 8x8 checkerboard pattern
checkerboard = np.zeros((8,8))
checkerboard[1::2, ::2] = 1
checkerboard[::2, 1::2] = 1
print("\n9. 8x8 Checkerboard Pattern:\n", checkerboard)

import numpy as np

# Given arrays
x = np.array([[1,2],[3,5]])
y = np.array([[5,6],[7,8]])
v = np.array([9,10])
w = np.array([11,12])

# 1. Add the two arrays
add_xy = x + y
print("x + y:\n", add_xy)




# 2. Subtract the two arrays
sub_xy = x - y
print("\nx - y:\n", sub_xy)




# 3. Multiply array with an integer (e.g., 3)
mul_x = x * 3
print("\nx * 3:\n", mul_x)




# 4. Square each element of the array
square_x = x**2
print("\nSquare of x:\n", square_x)




# 5. Dot products
dot_vw = np.dot(v, w)
dot_xv = np.dot(x, v)
dot_xy = np.dot(x, y)

print("\nDot product v . w:", dot_vw)

print("Dot product x . v:\n", dot_xv)

print("Dot product x . y:\n", dot_xy)



# 6. Concatenate arrays
concat_xy_row = np.concatenate((x, y), axis=0)      # along rows
concat_vw_col = np.concatenate((v.reshape(-1,1), w.reshape(-1,1)), axis=1)  # along columns
print("\n6. x and y concatenated along rows:\n", concat_xy_row)
print("   v and w concatenated along columns:\n", concat_vw_col)




# 7. Concatenate x and v (observe error)
try:
    concat_xv = np.concatenate((x, v), axis=0)
except ValueError as e:
    concat_xv = str(e)
print("\n7. Concatenate x and v error:\n", concat_xv)

import numpy as np

# Given matrices
A = np.array([[3, 4],
              [7, 8]])
B = np.array([[5, 3],
              [2, 1]])

# 1. Prove A * A^-1 = I
A_inv = np.linalg.inv(A)
identity = np.dot(A, A_inv)
print("1. A * A^-1 =\n", identity)

# 2. Prove AB != BA
AB = np.dot(A, B)
BA = np.dot(B, A)
print("\n2. AB =\n", AB)
print("   BA =\n", BA)
print("AB == BA? ->", np.array_equal(AB, BA))

# 3. Prove (AB)^T = B^T * A^T
AB_T = AB.T
BT_AT = np.dot(B.T, A.T)
print("\n3. (AB)^T =\n", AB_T)
print("   B^T * A^T =\n", BT_AT)
print("   check if (AB)^T == B^T * A^T? ->", np.array_equal(AB_T, BT_AT))

# 4. Solve system of linear equations using inverse
# Equations:
# 2x − 3y + z = −1
# x − y + 2z = −3
# 3x + y − z = 9

coeff = np.array([[2, -3, 1],
                  [1, -1, 2],
                  [3, 1, -1]])
const = np.array([-1, -3, 9])

solution = np.dot(np.linalg.inv(coeff), const)
print("\nSolution [x, y, z] =", solution)

# 5. Solve using np.linalg.solve (more efficient)
solution_solve = np.linalg.solve(coeff, const)
print("Solution using np.linalg.solve =", solution_solve)

import numpy as np
import time


# 1. Element-wise Addition


size = 1_000_000


list1 = list(range(size))
list2 = list(range(size))

start_time = time.time()
add_list = [a + b for a, b in zip(list1, list2)]
end_time = time.time()
print("Python List Addition Time:", end_time - start_time, "seconds")


arr1 = np.arange(size)
arr2 = np.arange(size)

start_time = time.time()
add_array = arr1 + arr2
end_time = time.time()
print("NumPy Array Addition Time:", end_time - start_time, "seconds")

# 2. Element-wise Multiplication



start_time = time.time()
mul_list = [a * b for a, b in zip(list1, list2)]
end_time = time.time()
print("\nPython List Multiplication Time:", end_time - start_time, "seconds")

start_time = time.time()
mul_array = arr1 * arr2
end_time = time.time()
print("NumPy Array Multiplication Time:", end_time - start_time, "seconds")

# 3. Dot Product


start_time = time.time()
dot_list = sum(a * b for a, b in zip(list1, list2))
end_time = time.time()
print("\nPython List Dot Product Time:", end_time - start_time, "seconds")


start_time = time.time()
dot_np = np.dot(arr1, arr2)
end_time = time.time()
print("NumPy Array Dot Product Time:", end_time - start_time, "seconds")

# 4. Matrix Multiplication



python_matrix_size = 200
numpy_matrix_size = 1000

mat1 = [[i+j for j in range(python_matrix_size)] for i in range(python_matrix_size)]
mat2 = [[i+j for j in range(python_matrix_size)] for i in range(python_matrix_size)]

start_time = time.time()
result_list = [
    [sum(mat1[i][k] * mat2[k][j] for k in range(python_matrix_size))
     for j in range(python_matrix_size)]
    for i in range(python_matrix_size)
]
end_time = time.time()
print(f"\nPython List Matrix Multiplication ({python_matrix_size}x{python_matrix_size}) Time:",
      end_time - start_time, "seconds")

matA = np.arange(numpy_matrix_size**2).reshape(numpy_matrix_size, numpy_matrix_size)
matB = np.arange(numpy_matrix_size**2).reshape(numpy_matrix_size, numpy_matrix_size)

start_time = time.time()
result_np = np.dot(matA, matB)
end_time = time.time()
print("NumPy Matrix Multiplication (1000x1000) Time:", end_time - start_time, "seconds")